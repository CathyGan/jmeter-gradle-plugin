This plugin enables you to run JMeter scripts from within gradle. 


Getting Started 
===============

### Edit your build.gradle

Create a build.gradle file and include the jmeter plugin as follows:

    apply plugin: 'jmeter'

        buildscript {
            repositories {
                mavenCentral()
            }
            dependencies {
                classpath "com.github.kulya:jmeter-gradle-plugin:1.4.0-2.6"
            }
        }

### Configure JMeter

JMeter is configured with a jmeter.properties file. By default this is in `src/test/jmeter/jmeter.properties`. This file can be empty, but is needed in order to run the tests.

### Edit JMeter files

By default the plugin will search for *.jmx files in `src/test/jmeter`. You can launch the UI end edit your files by running:

`gradle jmeterEditor`

### Run the tests

You can run the tests by executing 

`gradle jmeterRun`

The results of the tests will can be found in `build/jmeter-report`


Detailed Usage
==============

The gradle plugin adds the following tasks:

* jmeterCleanReport  - Cleans the reports
* jmeterListTestPlan - List JMeter test plan
* jmeterEditor       - Launches the gui, you can use this to edit your test plans.
* jmeterRun          - Runs the tests

The tasks can be configured through the use of the following properties.

* **srcDir**   - The directory containing the JMeter (.jmx) files. Tests are not guaranteed to be executed in order.  (*Default:  $project.dir/src/test/jmeter*)
* **includes** - JMeter files to be included.
* **excludes** - JMeter files to be excluded.
* **jmeterTestFiles** - List of JMeter test files (overrides srcDir). 
* **reportDir** - Directory where you want to store your reports (*Default: $project.buildDir/jmeter-report*)
* **enableReports** - Enable/Disable report generation (*Default: true*)
* **enableExtendedReports** - Enable/Disable extended report generation (*Default: false*). 
* **jmeterIgnoreFailure** - Ignore JMeter failures  (*Default: false*)
* **jmeterIgnoreError** - Ignore JMeter errors (*Default: false*)
* **reportPostfix** - Postfix that you want to use at report file  (*Default: "-report.html"*)
* **reportXslt** - Report XSLT location, if you want to use custom transformation
* **jmeterPropertyFile** - alternate properties file used to initalize Jmeter (*Default: $project.dir/src/test/jmeter//jmeter.properties*)
* **jmeterUserProperties** - List of JMeter user properties.
* **maxHeapSize** - Max heap size for jmeter process by default set to 512M. 
* **jmeterPluginJars** - plugin Jars Files, the name of the jar files.
* **jmeterEditFile** - JMeter file that you want to edit. This is used for jmeterEditor Task
* **jmeterUserPropertiesFiles** - List of user properties files

### Extended Reports

Setting the extended reports property to true will generate a set of graphs and .csv files that can assist with performance analysis. This relies on [jmeter-plugins](http://jmeter-plugins.org/) to create the reports. Setting this property to true will make the plugins available to your project as well.  If these jars are alread defined in the jmeterPluginJars property then those will be used. 

The extended report will generate the following reports:

- **ResponseTimesOverTime:** Graph for each sampler the average response time in milliseconds.
- **HitsPerSecond:**  The hits generated by the test plan to the server per second. Hits uncludes child samples from transactions and embedded resources hits.
- **BytesThroughputOverTime:** The amount of bytes sent and received by JMeter during the load test.
- **LatenciesOverTime:** The response latencies during the load test. A latency is the duration between the end of the request and the beginning of the server response.
- **ResponseCodesPerSecond:**  The response code per second returned during the test.
- **TransactionsPerSecond:** Shows the number of transactions per second for each sampler. It counts for each seconds the number of finished transactions.
- **ResponseTimesDistribution:** The response time distribution of the test. The X axis shows the response times grouped by interval, and the Y axis the number of samples which are contained in each interval.
- **ResponseTimesPercentiles:**  The percentiles for the response time values. X Axis represents percentage, Y Axis Response time values. One point (P, Value) means for the whole scenario, P percent of the values are bellow Value ms.
- **ThreadsStateOverTime:** Showing how many active threads are there in each thread group during test run.
- **TimesVsThreads:** This graph shows how Response Time changes with amount of parallel threads. Naturally, server takes longer to respond when a lot of users requests it simultaneously. This graph visualizes such dependencies.
- **ThroughputVsThreads:** Shows total server's transaction throughput for active test threads.

From a performance perspective it is best to disable *enableReports* and enable *enableExtendedReports* and make sure that `src/test/jmeter/jmeter.properties` contains the following:


	jmeter.save.saveservice.output_format=csv
	jmeter.save.saveservice.data_type=false
	jmeter.save.saveservice.label=true
	jmeter.save.saveservice.response_code=true
	jmeter.save.saveservice.response_data.on_error=false
	jmeter.save.saveservice.response_message=false
	jmeter.save.saveservice.successful=true
	jmeter.save.saveservice.thread_name=true
	jmeter.save.saveservice.time=true
	jmeter.save.saveservice.subresults=false
	jmeter.save.saveservice.assertions=false
	jmeter.save.saveservice.latency=true
	jmeter.save.saveservice.bytes=true
	jmeter.save.saveservice.hostname=true
	jmeter.save.saveservice.thread_counts=true
	jmeter.save.saveservice.sample_count=true
	jmeter.save.saveservice.response_message=false
	jmeter.save.saveservice.assertion_results_failure_message=false
	jmeter.save.saveservice.default_delimiter=;
	jmeter.save.saveservice.print_field_names=true
	jmeter.save.saveservice.autoflush=true
	jmeter.save.saveservice.timestamp_format=ms
		
and your build.gradle:

	jmeterRun.configure {
	    enableReports = false
	    enableExtendedReports = true
	}

The reason is that enableReports relies on xml generation which consumes more memory.
	
### Running Large Scale Tests

* Listeners receive Sample Results and do some processing with it, this takes resources (memory, CPU) so during Load Testing, a very simple rule is to **REMOVE ALL LISTENERS!**. 
* Do not generate XML output_format.
* The more it computes to create or process your samples, the less time it spends sampling, so when doing custom coding, ensure it is efficient.
* Post-Processor and Assertions have a cost, Ensure you use them when required and use the ones that consume less memory and CPU.
	- Use Regular Expression Extractor for extracting data
	- Avoid XPath Extractor when possible. 
	- Use Response Assertion or Size assertion.
* If you are scripting in requests, use the most efficient scripting option, which is **JSR223 + Groovy + Caching**. It is [7 times faster](http://mail-archives.apache.org/mod_mbox/jmeter-dev/201301.mbox/%3CCAH9fUpa_BWtcQDg3etUE5OuVj_QeOC0YdenkqTFhurxp%2B2P9MQ%40mail.gmail.com%3E) then the alternatives. 
	- Use .groovy files instead of keeping the Groovy code inside the sampler. Make sure you have the Compilation Cache Key set if you use groovy in the sampler.
	- Don’t refer any variables as ${VAR} inside the Groovy script. Use either vars.get(“VAR”) or the Parameters stanza of JSR233 Sampler 
* If that is not fast enough implement your own sampler in java. [See](http://blazemeter.com/blog/beanshell-vs-jsr223-vs-java-jmeter-scripting-its-performance) for a performance comparison of various scripting solutions.
* Disable *enableReports* and enable *enableExtendedReports*, and disable the generation of XML during the test. Set: *jmeter.save.saveservice.output_format=csv* in your jmeter.properties file.
* You can find more hints and tips [here](http://jmeter.apache.org/usermanual/best-practices.html).

Following those recommendations you can reach easily up to 5000 threads on a standard basic machine, 10000 threads on a m3.xlarge. If this is not sufficient to model your load consider the following:

* Deploy to the cloud: [jmeter-ec2](https://github.com/oliverlloyd/jmeter-ec2)

